<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.dev.js"></script>
  <style>
    #frame {
      position: relative;
      height: 540px;
      width: 960px;
      border: 5px solid black;
      margin: 100px auto;
      background: #cccccc;
    }

    .layer {
      position: absolute;
      left: 0;
      top: 0;
      height: 540px;
      width: 960px;
    }

    #whiteboard {
      z-index: 10;
      opacity: 50%;
    }

    #canvas {
      z-index: 5;
    }
  </style>
</head>

<body>
  <div id="frame">
    <div id="whiteboard" class="layer"></div>
    <canvas id="canvas" class="layer" height="540px" width="960px"></canvas>
  </div>
  <script>

    const generateGuid = () => {
      function _p8(s) {
        var p = (Math.random().toString(16) + "000000000").substr(2, 8);
        return s ? "-" + p.substr(0, 4) + "-" + p.substr(4, 4) : p;
      }
      return _p8() + _p8(true) + _p8(true) + _p8();
    }


    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }


    class Socket {
      constructor(url, roomKey, receivePathMethod, receiveBackfillMethod) {
        this.socket = io.connect(url);
        this.connected = false;
        this.receivePathMethod = receivePathMethod;
        this.receiveBackfillMethod = receiveBackfillMethod;
        this.setupHandlers(roomKey);
      }
      setupHandlers(roomKey) {
        this.socket.on('connect', () => {
          this.connected = true;
          this.socket.emit('login', { room: roomKey })
        });
        this.socket.on('disconnect', () => {
          this.connected = false;
        });
        this.socket.on('display', (data) => {
          this.receivePathMethod(data.map(pointArray => new Point(pointArray[0], pointArray[1])));
        });
        this.socket.on('backfill', (data) => {
          var p = data.paths.map(path => path.map(pointArray => new Point(pointArray[0], pointArray[1])));
          this.receiveBackfillMethod(p);
        });
      }
      sendPath(path, roomKey) {
        this.socket.emit('draw', {
          room: roomKey,
          path: path.map(point => [point.x, point.y])
        })
      }
    }


    class Whiteboard {
      constructor(sendPathMethod) {
        this.whiteboard = document.getElementById("whiteboard");
        this.canvas = document.getElementById("canvas");
        this.context = canvas.getContext("2d");
        this.mousePressed = false;

        this.sendPathMethod = sendPathMethod;

        this.paths = [];
        this.currentPath = [];
        this.prevPoint = null;

        this.markerColor = "black";

        this.addEventListeners();
      }

      addEventListeners() {
        this.whiteboard.addEventListener("mousemove", this.handleMouseEvent.bind(this));
        this.whiteboard.addEventListener("mousedown", this.handleMouseEvent.bind(this));
        this.whiteboard.addEventListener("mouseup", this.handleMouseEvent.bind(this));
        this.whiteboard.addEventListener("mouseout", this.handleMouseEvent.bind(this));
      }

      handleMouseEvent(event) {
        if (event.type === "mouseup" || event.type === "mouseout") {
          this.prevPoint = null;
          this.mousePressed = false;
          if (this.currentPath.length > 0){
            this.sendCoordinates()
          }
        }
        if (event.type === "mousedown") {
          this.mousePressed = true;
        }
        if (this.mousePressed) {
          this.storeCoordinates(new Point(event.offsetX, event.offsetY));
        }
      }

      drawLine(prevPoint, newPoint) {
        if (prevPoint !== null) {
          this.context.beginPath();
          this.context.moveTo(prevPoint.x, prevPoint.y);
          this.context.lineTo(newPoint.x, newPoint.y);
          this.context.stroke();
          this.context.closePath();
        }
      }

      drawPath(path) {
        let prevPoint = null;
        path.forEach((point, index) => {
          if (index !== 0) {
            this.drawLine(prevPoint, point);
          }
          prevPoint = point;
        })
      }

      storeCoordinates(point) {
        this.currentPath.push(point);
        if (this.prevPoint) {
          this.drawLine(this.prevPoint, point);
        }
        this.prevPoint = point;
      }

      sendCoordinates() {
        this.paths.push(this.currentPath);
        this.sendPathMethod(this.currentPath)
        this.currentPath = []
      }

      receivePath(path) {
        this.drawPath(path);
      }
      receiveBackfill(backfill) {
        console.log(backfill)
        backfill.forEach(path => {
          this.drawPath(path);
        })
      }
    }


    class App {
      constructor(url) {
        this.roomKey = location.hash.substring(1) || generateGuid();
        location.hash = this.roomKey;
        this.socket = new Socket(
          url, 
          this.roomKey, 
          this.receivePath.bind(this),
          this.receiveBackfill.bind(this),
        );
        this.whiteboard = new Whiteboard(this.sendPath.bind(this));
      }
      sendPath(path) {
        this.socket.sendPath(path, this.roomKey);
      }
      receivePath(path) {
        this.whiteboard.receivePath(path);
      }
      receiveBackfill(backfill) {
        this.whiteboard.receiveBackfill(backfill);
      }
    }
    let app = new App("http://localhost:5000");
  </script>
</body>

</html>